# 内存及垃圾回收
## 内存空间
- 栈(存放变量)
- 堆(存放复杂对象)
- 池(存放常量)
![Memoryspace](/Memoryspace.png)
## 内存生命周期
1. 内存分配: 当我们声明变量 函数 对象的时候 系统会自动分配内存
2. 内存使用: 即读写内存 也就是使用变量 函数
3. 内存回收: 使用完毕 由垃圾回收机制自动回收
## 垃圾回收
> 由于字符串、对象和数组没有固定大小，所以当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript 序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。——《JavaScript 权威指南》
两种策略:
### 引用计数法
>跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1，如果这个值再被赋值给另一个变量，则引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1。当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存。

`问题`:
循环引用，就是说对象 a 包含一个指向 b 的指针，对象 b 也包含一个指向 a 的引用。 这就可能造成大量内存得不到回收，也就是内存泄漏
```
function problem() {
  var a = new Object();
  var b = new Object();
  a.ref = b;
  b.ref = a;
}
```
### 标记清除法
> 当程序执行流入到一个函数中时，会创建该函数的执行上下文，执行上下文中的变量都会被标记为 进入环境，从逻辑上讲，永远不能释放 进入执行环境 变量所占用的内存。因为只要执行流进入相应的执行上下文，就可能会用到这些变量。
工作流程
1. 垃圾收集器在运行的时候会给存储在内存的中的 所有变量都加上标记
2. 去掉 执行上下文中的变量 以及 被环境中的变量引用的变量 的标记
3. 那些 还存在标记的变量将被视为准备删除的变量
4. 最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间
手动释放内存`let a=1; a=null;`
## 堆栈溢出
指内存空间已经被申请完，没有足够的内存提供了
## 内存泄漏
指申请的内存执行完后没有及时的清理或者销毁，占用空闲内存，内存泄漏过多的话，就会导致后面的进程申请不到内存。因此内存泄漏会导致内部内存溢出
- 原因
    - 全局变量引起的内存泄漏
    - 没有被清除的定时器
    - 闭包
- 解决方法
    - 减少全局变量的使用
    - 减少闭包的使用
    - 避免死循环
    - 及时清除不用内存





