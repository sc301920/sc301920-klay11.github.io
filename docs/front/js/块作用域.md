# 块作用域
> 任何一对花括号中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为 块级作用域。
## 声明关键字
### var
ES5 及之前是没有块级变量这个说法的，常规性是用 闭包 来防止内存泄漏。
- 函数内的变量若是带 var 声明，则会覆盖外部的全局变量 优先使用
- 若是函数内部声明变量不带 var 声明，则直接 覆盖同名的全局变量
- 函数内存在 声明提升 的情况，可以先使用后声明
- for 循环中的 var 会污染全局（不局限于循环内）
### let
let 声明使用方法基本和 var 相同，而且声明的变量只在其块和子块中可用。 二者之间最主要的区别在于 var 声明的变量的作用域是整个封闭函数。
利用这个特性来替代立即执行函数（IIFE）
```
(function () {
  var number = 1;
})();

{
  let number = 1;
}
```
- 不允许重新声明同名变量，会抛出异常，具有唯一性
- 不允许没声明就使用，会抛出异常，只有执行该声明的时候才能使用
- 有自己特色的闭包特性，比如在 for 循环的应用中
### const
const 的用法跟 let 差不多，但是 const 一定要赋值，不赋值会报错
**const 声明的变量记录的是 指针，不可更改的是 指针，如果 const 所声明的是对象，对象的内容还是可以修改的。**

## 暂时性死区
使用 let 或 const 声明的变量，在声明赋值没有到达之前，访问该变量都会导致报错，就连一直以为安全的 typeof 也不再安全
```
// TDZ1
function foo() {
  // TDZ 开始
  console.log(typeof number);
  let number = 5; // TDZ 结束
}
foo(); // ReferenceError: number is not defined
```
报的错是 ReferenceError，如果使用 var 声明的话，number 输出应该是 undefined，从 let 声明的变量的块的第一行，到声明变量之间的这个区域被称作 暂时性死区（TDZ）。凡是在这个区域使用这些变量都会报错。

## 显式块级作用域
在嵌套的作用域内使用 let 声明同一变量是被允许的。这个嵌套的作用域，在 ES6 中又称 显式块级作用域。
```
function foo() {
  var bar = 1;
  {
    let bar = 2;
  }

  console.log(bar);
}
function zoo() {
  var bar = 1;
  {
    var bar = 2;
  }

  console.log(bar);
}
foo(); // 1
zoo(); // 2
```
因为是 let 和 const 是块级作用域，声明的变量在当前块使用完之后就会被释放, 而var会覆盖外部作用域的变量



