# 对结构
## 完全二叉树
- 从第一层到倒数第二层，每一层都是满的，也就是说每一层的结点数都达到了当前层所能达到的最大值
- 最后一层的结点是从左到右连续排列的，不存在跳跃排列的情况（也就是说这一层的所有结点都集中排列在最左边）。
![heapup](/heapup.png)
1. 索引为 (n-1)/2 的结点是它的父结点
2. 索引 2*n+1 的结点是它的左孩子结点
3. 索为引 2*n+2 的结点是它的右孩子结点
## 什么是堆
堆是完全二叉树的一种特例
1. 每个结点的结点值都不小于其左右孩子的结点值，这样的完全二叉树就叫做“大顶堆”
2. 树中每个结点值都不大于其左右孩子的结点值，这样的完全二叉树就叫做“小顶堆”
## 堆的基本操作
- 如何取出堆顶元素（删除操作）
- 往堆里追加一个元素（插入操作）
### 取出
1. 用堆里的最后一个元素替换掉堆顶元素。
2. 对比新的堆顶元素与其左右孩子的值，如果其中一个孩子大于堆顶元素，则交换两者的位置：
```
// 入参是堆元素在数组里的索引范围，low表示下界，high表示上界
function downHeap(low, high) {
    // 初始化 i 为当前结点，j 为当前结点的左孩子
    let i=low,j=i*2+1 
    // 当 j 不超过上界时，重复向下对比+交换的操作
    while(j <= high) {
        // 如果右孩子比左孩子更大，则用右孩子和根结点比较
        if(j+1 <= high && heap[j+1] > heap[j]) {
            j = j+1
        }
        
        // 若当前结点比孩子结点小，则交换两者的位置，把较大的结点“拱上去”
        if(heap[i] < heap[j]) {
            // 交换位置
            const temp = heap[j]  
            heap[j] = heap[i]  
            heap[i] = temp
            
            // i 更新为被交换的孩子结点的索引
            i=j  
            // j 更新为孩子结点的左孩子的索引
            j=j*2+1
        } else {
            break
        }
    }
}
```
